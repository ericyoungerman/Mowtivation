---
title: "Soybean population"

output:
  github_document:
    toc: true
always_allow_html: true


---
#Setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo    = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.path = "figs/analysis/bean_yield-"
)
```
# Packages
```{r}
# Packages
library(tidyverse)    # includes dplyr, ggplot2, readr, tibble, etc.
library(janitor)
library(readxl)
library(glmmTMB)
library(DHARMa)
library(emmeans)
library(multcomp)
library(car)
library(kableExtra)
library(here)
library(conflicted)
library(lme4)
library(WrensBookshelf)


# Handle conflicts
conflicts_prefer(dplyr::select)
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::recode)

# Treatment level order (use everywhere)
mow_levels <- c(
  "Rolled, no control",
  "Rolled, mowing",
  "Rolled, high-residue cultivation",
  "Tilled, mowing",
  "Tilled, cultivation"
)

# One consistent CVD-safe color palette for all figures (WrensBookshelf)
fill_cols <- WB_brewer(
  name = "WhatWellBuild",
  n    = length(mow_levels),
  type = "discrete"
) |>
  setNames(mow_levels)

# x-axis label helpers ---------------------------------------------------

# Break on spaces (if you ever want every word on its own line)
label_break_spaces <- function(x) {
  stringr::str_replace_all(x, " ", "\n")
}

# Break after the comma: "Rolled,\nno control", etc.
label_break_comma <- function(x) {
  stringr::str_replace_all(x, ", ", ",\n")
}

# Break after comma AND split "high-residue cultivation"
# -> "Rolled,\nhigh-residue\ncultivation"
label_break_comma_cult <- function(x) {
  x |>
    stringr::str_replace("high-residue cultivation",
                         "high-residue\ncultivation") |>
    stringr::str_replace_all(", ", ",\n")
}

# Helper: tidy emmeans output regardless of CI column names --------------
# (works directly on an emmeans object)

tidy_emm <- function(emm, ref_levels = NULL) {
  emm_df <- as.data.frame(emm)

  lcl_col <- intersect(c("lower.CL", "asymp.LCL"), names(emm_df))[1]
  ucl_col <- intersect(c("upper.CL", "asymp.UCL"), names(emm_df))[1]

  if (is.na(lcl_col) || is.na(ucl_col)) {
    stop("Could not find CI columns in emmeans output.")
  }

  out <- emm_df |>
    dplyr::mutate(
      ci_low  = .data[[lcl_col]],
      ci_high = .data[[ucl_col]]
    )

  if (!is.null(ref_levels) && "weed_trt" %in% names(out)) {
    out <- out |>
      dplyr::mutate(weed_trt = factor(weed_trt, levels = ref_levels))
  }

  out
}
```


# Data import & prep

``` {r}
bean_population_clean <- read_excel(
  here("data", "raw", "All Treatments", "combined_raw.xlsx")
) |>
  clean_names() |>
  rename(weed_trt = treatment) |>
  mutate(
    year      = factor(year),
    location  = factor(location),
    site_year = factor(interaction(year, location, drop = TRUE)),
    block     = factor(block),
    weed_trt  = recode(
      weed_trt,
      "RNO" = "Rolled, no control",
      "RIM" = "Rolled, mowing",
      "RIC" = "Rolled, high-residue cultivation",
      "TIM" = "Tilled, mowing",
      "TIC" = "Tilled, cultivation"
    ),
    weed_trt = factor(weed_trt, levels = mow_levels)
  ) |>
  # keep only rows with non-missing population
  filter(!is.na(bean_population)) |>
  # optional per-area metrics, analogous to emergence
  mutate(
    bean_population_two_meter = bean_population * 2,
    bean_population_hectare   = (bean_population / 0.762) * 10000,
    bean_population_acre      = bean_population_hectare / 2.471
  )

# 2023 Field V subset (for the boxplot later)
bean_population_field_v_2023 <- bean_population_clean |>
  filter(year == 2023, location == "field v")

# Quick check
kable(
  head(bean_population_clean),
  caption = "All site-years, cleaned (bean population)"
)

```

# Model testing
### Exploratory Analysis: Soybean population
```{r}
# 1) Summary table: bean population by site-year × treatment
bean_population_clean |>
  group_by(site_year, weed_trt) |>
  summarise(
    n      = n(),
    mean   = mean(bean_population_hectare, na.rm = TRUE),
    median = median(bean_population_hectare, na.rm = TRUE),
    sd     = sd(bean_population_hectare, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(site_year, weed_trt) |>
  kable(
    digits  = 1,
    caption = "Bean population (plants ha⁻¹) by site-year × treatment"
  ) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

# 2) Faceted boxplot: all site-years
bean_population_clean |>
  ggplot(aes(x = weed_trt, y = bean_population_hectare, fill = weed_trt)) +
  geom_boxplot(
    outlier.shape = NA,
    width  = 0.55,
    color  = "black"
  ) +
  geom_jitter(
    width  = 0.12,
    height = 0,
    alpha  = 0.4,
    size   = 1.8,
    color  = "grey30"
  ) +
  facet_wrap(~ site_year, nrow = 1) +
  scale_fill_manual(values = fill_cols, guide = "none") +
  scale_x_discrete(labels = label_break_comma_cult) +
  scale_y_continuous(labels = scales::label_comma()) +
  labs(
    x     = NULL,
    y     = expression(Bean~population~"(plants"~ha^{-1}*")"),
    title = "Bean population by treatment across site-years"
  ) +
  theme_classic(base_size = 14) +
  theme(
    axis.text.x = element_text(size = 10),
    strip.text  = element_text(face = "bold")
  )

# 3) Boxplot: 2023 – Field V only
bean_population_field_v_2023 |>
  ggplot(aes(x = weed_trt, y = bean_population_hectare, fill = weed_trt)) +
  geom_boxplot(
    outlier.shape = NA,
    width  = 0.55,
    color  = "black"
  ) +
  geom_jitter(
    width  = 0.12,
    height = 0,
    alpha  = 0.4,
    size   = 1.8,
    color  = "grey30"
  ) +
  scale_fill_manual(values = fill_cols, guide = "none") +
  scale_x_discrete(labels = label_break_comma_cult) +
  scale_y_continuous(labels = scales::label_comma()) +
  labs(
    x     = NULL,
    y     = expression(Bean~population~"(plants"~ha^{-1}*")"),
    title = "Bean population by treatment, 2023 – Field V"
  ) +
  theme_classic(base_size = 14) +
  theme(
    axis.text.x = element_text(size = 10)
  )

```
## Selection
```{r}
### Model testing / selection for bean population (plants ha⁻¹)

options(contrasts = c("contr.sum", "contr.poly"))

# Interaction model: weed_trt * site_year --------------------------------
pop_int <- lmer(
  bean_population_hectare ~ weed_trt * site_year + (1 | site_year:block),
  data = bean_population_clean
)

# Additive model: weed_trt + site_year -----------------------------------
pop_add <- lmer(
  bean_population_hectare ~ weed_trt + site_year + (1 | site_year:block),
  data = bean_population_clean
)

# Compare models (AIC + LRT) ---------------------------------------------
# AIC table
aic_population <- tibble(
  model = c(
    "Additive: weed_trt + site_year",
    "Interaction: weed_trt * site_year"
  ),
  AIC = c(AIC(pop_add), AIC(pop_int))
)

# Likelihood-ratio test (is the interaction worth keeping?)
lrt_pop <- anova(pop_add, pop_int)

p_int_pop <- lrt_pop$`Pr(>Chisq)`[2]

# Apply your rule: choose simpler additive model unless interaction is clearly needed
chosen_model_name_pop <- if (p_int_pop < 0.05) {
  "Interaction: weed_trt * site_year"
} else {
  "Additive: weed_trt + site_year"
}

pop.lmer <- if (p_int_pop < 0.05) pop_int else pop_add

# Add ΔAIC and "Selected" flag to the table ------------------------------
aic_population_out <- aic_population |>
  mutate(
    deltaAIC = AIC - min(AIC),
    Selected = if_else(model == chosen_model_name_pop, "Yes", "")
  )

kable(
  aic_population_out,
  digits  = 2,
  caption = "Bean population (plants ha⁻¹): model comparison (additive vs interaction)"
) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

# Also show the LRT table (optional but handy)
lrt_pop

# Quick text reminder of which model is used downstream ------------------
cat(
  "\nSelected model for bean population (used in all downstream emmeans/plots):\n  ",
  chosen_model_name_pop,
  sprintf("  [LRT p = %.3f]\n", p_int_pop)
)

# Diagnostics on chosen model --------------------------------------------
set.seed(123)
res_pop <- DHARMa::simulateResiduals(pop.lmer)
plot(res_pop)
DHARMa::testDispersion(pop.lmer)

car::Anova(pop.lmer, type = 3)

```
### Post-hoc summary table
```{r}
### Bean population (plants ha⁻¹) with Fisher's LSD CLDs

# Estimated marginal means for weed_trt
emm_pop <- emmeans(pop.lmer, ~ weed_trt)

# Tidy emmeans (adds ci_low / ci_high and enforces treatment order)
emm_pop_df <- tidy_emm(emm_pop, ref_levels = mow_levels) |>
  as_tibble()

# Compact letter display (Fisher's LSD, no adjustment; "a" = highest)
cld_pop <- cld(
  emm_pop,
  adjust   = "none",
  Letters  = letters,
  sort     = TRUE,
  reversed = TRUE   # "a" = highest group(s)
) |>
  as_tibble() |>
  mutate(
    weed_trt = factor(weed_trt, levels = mow_levels),
    .group   = str_trim(.group)
  ) |>
  select(weed_trt, .group)

# Join emmeans + CLDs and format for reporting
emm_pop_df |>
  left_join(cld_pop, by = "weed_trt") |>
  select(weed_trt, emmean, SE, ci_low, ci_high, .group) |>
  mutate(across(c(emmean, SE, ci_low, ci_high), ~ round(.x, 1))) |>
  kable(
    caption   = "Estimated bean population (plants ha⁻¹) with 95% CI and Fisher's LSD group letters",
    col.names = c("Treatment", "Mean", "SE", "Lower CI", "Upper CI", "Group")
  ) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))


```
### ANOVA-style summary tables for bean population
```{r}

## ANOVA-style summary tables for bean population ------------------------

## 1) P-value summary (Location, Treatment, Interaction) -----------------

# Type-III tests for additive model (weed_trt + site_year)
anova_pop <- Anova(pop.lmer, type = 3)

anova_pop_df <- anova_pop |>
  as.data.frame() |>
  tibble::rownames_to_column("Effect")

# LRT for interaction (additive vs interaction models)
anova_interaction_pop <- anova(pop_add, pop_int)

pvals_pop <- tibble(
  Effect = c("Location (site_year)", "Treatment (weed_trt)", "Location × Treatment"),
  p_raw  = c(
    anova_pop_df$`Pr(>Chisq)`[anova_pop_df$Effect == "site_year"],
    anova_pop_df$`Pr(>Chisq)`[anova_pop_df$Effect == "weed_trt"],
    anova_interaction_pop$`Pr(>Chisq)`[2]
  )
) |>
  mutate(
    `P-value` = case_when(
      p_raw < 0.001 ~ "<0.001",
      p_raw < 0.01  ~ "<0.01",
      TRUE          ~ sprintf("%.3f", p_raw)
    )
  ) |>
  select(Effect, `P-value`)

pvals_pop |>
  kable(
    caption   = "Bean population (plants ha⁻¹): P-values for location, treatment, and interaction",
    col.names = c("Effect", "P-value")
  ) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))


## 2) Location block: site-year means (model + raw) ----------------------

# Model-based emmeans by site_year
emm_loc_pop <- emmeans(pop.lmer, ~ site_year)

emm_loc_pop_df <- tidy_emm(emm_loc_pop) |>
  as_tibble() |>
  mutate(
    site_year  = as.factor(site_year),
    model_mean = emmean
  ) |>
  select(site_year, model_mean)

# CLDs for site_year (a = highest)
cld_loc_pop <- cld(
  emm_loc_pop,
  adjust   = "none",
  Letters  = letters,
  sort     = TRUE,
  reversed = TRUE
) |>
  as_tibble() |>
  mutate(
    site_year = as.factor(site_year),
    loc_CLD   = str_trim(.group)
  ) |>
  select(site_year, loc_CLD)

# Raw means by site_year
raw_loc_pop <- bean_population_clean |>
  group_by(site_year) |>
  summarise(
    raw_mean = mean(bean_population_hectare, na.rm = TRUE),
    .groups  = "drop"
  ) |>
  mutate(site_year = as.factor(site_year))

loc_summary_pop <- emm_loc_pop_df |>
  left_join(cld_loc_pop, by = "site_year") |>
  left_join(raw_loc_pop, by = "site_year") |>
  mutate(
    model_mean = round(model_mean, 1),
    raw_mean   = round(raw_mean, 1),
    raw_CLD    = loc_CLD  # use same letters for model + raw
  ) |>
  arrange(site_year)

loc_summary_pop |>
  kable(
    caption   = "Bean population (plants ha⁻¹): location (site-year) means with CLDs",
    col.names = c("Site-year", "Model mean", "Model CLD", "Raw mean", "Raw CLD")
  ) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))


## 3) Treatment block: means (model + raw) -------------------------------

# emmeans for treatment
emm_pop <- emmeans(pop.lmer, ~ weed_trt)

emm_trt_pop_df <- tidy_emm(emm_pop, ref_levels = mow_levels) |>
  as_tibble() |>
  mutate(
    weed_trt   = factor(weed_trt, levels = mow_levels),
    model_mean = emmean
  ) |>
  select(weed_trt, model_mean)

# CLDs for treatment (a = highest)
cld_pop <- cld(
  emm_pop,
  adjust   = "none",
  Letters  = letters,
  sort     = TRUE,
  reversed = TRUE
) |>
  as_tibble() |>
  mutate(
    weed_trt = factor(weed_trt, levels = mow_levels),
    trt_CLD  = str_trim(.group)
  ) |>
  select(weed_trt, trt_CLD)

# Raw means by treatment
raw_trt_pop <- bean_population_clean |>
  group_by(weed_trt) |>
  summarise(
    raw_mean = mean(bean_population_hectare, na.rm = TRUE),
    .groups  = "drop"
  ) |>
  mutate(weed_trt = factor(weed_trt, levels = mow_levels))

trt_summary_pop <- emm_trt_pop_df |>
  left_join(cld_pop, by = "weed_trt") |>
  left_join(raw_trt_pop, by = "weed_trt") |>
  mutate(
    model_mean = round(model_mean, 1),
    raw_mean   = round(raw_mean, 1),
    raw_CLD    = trt_CLD
  ) |>
  arrange(weed_trt)

trt_summary_pop |>
  kable(
    caption   = "Bean population (plants ha⁻¹): treatment means with CLDs",
    col.names = c("Treatment", "Model mean", "Model CLD", "Raw mean", "Raw CLD")
  ) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))


## 4) Interaction block: site-year × treatment means ---------------------

# Model emmeans by treatment within site_year
emm_sy_pop <- emmeans(pop.lmer, ~ weed_trt | site_year)

emm_sy_pop_df <- tidy_emm(emm_sy_pop, ref_levels = mow_levels) |>
  as_tibble() |>
  mutate(
    weed_trt   = factor(weed_trt, levels = mow_levels),
    site_year  = as.factor(site_year),
    model_mean = emmean
  ) |>
  select(site_year, weed_trt, model_mean)

# CLDs within each site_year (a = highest within that site_year)
cld_sy_pop <- cld(
  emm_sy_pop,
  adjust   = "none",
  Letters  = letters,
  sort     = TRUE,
  reversed = TRUE
) |>
  as_tibble() |>
  mutate(
    weed_trt  = factor(weed_trt, levels = mow_levels),
    site_year = as.factor(site_year),
    int_CLD   = str_trim(.group)
  ) |>
  select(site_year, weed_trt, int_CLD)

# Raw means by site_year × treatment
raw_sy_pop <- bean_population_clean |>
  group_by(site_year, weed_trt) |>
  summarise(
    raw_mean = mean(bean_population_hectare, na.rm = TRUE),
    .groups  = "drop"
  ) |>
  mutate(
    site_year = as.factor(site_year),
    weed_trt  = factor(weed_trt, levels = mow_levels)
  )

int_summary_pop <- emm_sy_pop_df |>
  left_join(cld_sy_pop, by = c("site_year", "weed_trt")) |>
  left_join(raw_sy_pop, by = c("site_year", "weed_trt")) |>
  mutate(
    model_mean = round(model_mean, 1),
    raw_mean   = round(raw_mean, 1),
    raw_CLD    = int_CLD
  ) |>
  arrange(site_year, weed_trt)

int_summary_pop |>
  kable(
    caption   = "Bean population (plants ha⁻¹): site-year × treatment means with CLDs",
    col.names = c(
      "Site-year", "Treatment",
      "Model mean", "Model CLD",
      "Raw mean",   "Raw CLD"
    )
  ) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))


```
# Figures
## Pooled model
```{r}

# Figure: Bean population by weed management treatment (pooled across site-years)

# Estimated marginal means for treatments
emm_pop <- emmeans(pop.lmer, ~ weed_trt)

# Tidy emmeans for plotting
plot_df_pop <- tidy_emm(emm_pop, ref_levels = mow_levels) |>
  as_tibble() |>
  mutate(
    response = emmean,
    ymin     = pmax(response - SE, 0),
    ymax     = response + SE
  )

# Plot (no CLD letters)
ggplot(plot_df_pop, aes(x = weed_trt, y = response, fill = weed_trt)) +
  geom_col(width = 0.7, color = "black") +
  geom_errorbar(aes(ymin = ymin, ymax = ymax), width = 0.14) +
  scale_fill_manual(values = fill_cols, guide = "none") +
  scale_x_discrete(labels = label_break_comma_cult) +
  scale_y_continuous(labels = scales::label_comma()) +
  labs(
    x       = NULL,
    y       = expression(Bean~population~"(plants"~ha^{-1}*")"),
    title   = "Bean population by weed management",
    caption = "Model-based means (plants"~ha^{-1}*") ±  SE across weed management treatments."
  ) +
  theme_classic(base_size = 18) +
  theme(
    axis.text.x    = element_text(lineheight = 0.95, margin = margin(t = 8)),
    axis.title.y   = element_text(margin = margin(r = 8)),
    plot.title     = element_text(face = "bold"),
    plot.caption   = element_text(size = 9, hjust = 0)
  )

# Save figure
ggsave(
  filename = here("figs", "analysis", "fig_bean_population_mowing_pooled.png"),
  width    = 7.5,
  height   = 5.5,
  dpi      = 300
)


```
## Pooled Raw

```{r}
# Figure: Bean population by weed management treatment (raw means ± SE)

# 1) Raw means and SE by treatment --------------------------------------
raw_pop_summary <- bean_population_clean |>
  group_by(weed_trt) |>
  summarise(
    n    = n(),
    mean = mean(bean_population_hectare, na.rm = TRUE),
    sd   = sd(bean_population_hectare, na.rm = TRUE),
    se   = sd / sqrt(n),
    .groups = "drop"
  ) |>
  mutate(
    weed_trt = factor(weed_trt, levels = mow_levels),
    ymin     = pmax(mean - se, 0),
    ymax     = mean + se
  )

# 2) Plot (raw means ± SE, no CLD letters) ------------------------------
ggplot(raw_pop_summary, aes(x = weed_trt, y = mean, fill = weed_trt)) +
  geom_col(width = 0.7, color = "black") +
  geom_errorbar(aes(ymin = ymin, ymax = ymax), width = 0.14) +
  scale_fill_manual(values = fill_cols, guide = "none") +
  scale_x_discrete(labels = label_break_comma_cult) +
  scale_y_continuous(labels = scales::label_comma()) +
  labs(
    x       = NULL,
    y       = expression(Bean~population~"(plants"~ha^{-1}*")"),
    title   = "Bean population by weed management",
    caption = "Raw means (plants"~ha^{-1}*") ± SE across weed management treatments."
  ) +
  theme_classic(base_size = 18) +
  theme(
    axis.text.x    = element_text(lineheight = 0.95, margin = margin(t = 8)),
    axis.title.y   = element_text(margin = margin(r = 8)),
    plot.title     = element_text(face = "bold"),
    plot.caption   = element_text(size = 9, hjust = 0)
  )

# Save figure
ggsave(
  filename = here("figs", "analysis", "fig_bean_population_mowing_pooled_raw.png"),
  width    = 7.5,
  height   = 5.5,
  dpi      = 300
)

```

